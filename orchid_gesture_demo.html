<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Orchid Gesture Particles</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
      }
      #info {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        font-family:
          San Francisco,
          sans-serif;
        pointer-events: none;
        z-index: 100;
      }
      #webcam {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 200px;
        transform: scaleX(-1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 10px;
      }
      #loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        color: #ff0080;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 24px;
        font-family: monospace;
        transition: opacity 1s;
        z-index: 200;
      }
      #audio-controls {
        position: absolute;
        bottom: 20px;
        left: 20px;
        z-index: 100;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      #play-btn {
        background: linear-gradient(135deg, #ff0080, #7928ca);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 16px;
        font-family: sans-serif;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(255, 0, 128, 0.4);
      }
      #play-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(255, 0, 128, 0.6);
      }
      #audio-info {
        color: rgba(255, 255, 255, 0.6);
        font-family: monospace;
        font-size: 12px;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="loading">Loading Orchid Model...</div>
    <div id="info">
      <h1>Orchid Gesture Control</h1>
      <p>
        Detected:
        <span id="gesture-state" style="font-weight: bold; color: #ff0080"
          >Waiting...</span
        >
      </p>
      <p>Open Palm: Dissipate | Fist: Converge</p>
      <p id="audio-status" style="color: #7928ca">Click Play to start music</p>
    </div>
    <video id="webcam" autoplay playsinline></video>
    <div id="audio-controls">
      <button id="play-btn" onclick="toggleAudio()">â–¶ Play Music</button>
      <div id="audio-info">Bass: 0 | Mid: 0 | Treble: 0</div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/examples/jsm/loaders/GLTFLoader": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js",
          "three/examples/jsm/controls/OrbitControls": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>

    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";
      import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

      // --- Config ---
      const CONFIG = {
        particleCount: 150000, // 80k Base + 70k Extra for Dissipation
        modelPath: "models/orchid_flower.glb",
        baseColor: new THREE.Color("#ff0080"),
        dissipateStrength: 15.0,
        audioPath:
          "Audio/UPM_EAS86_103_Trouble_Cleansing_Instrumental_Lam_2038336.wav",
      };

      // --- Globals ---
      let scene, camera, renderer, controls, particles;
      let uProgress = 0;
      let targetProgress = 0;
      let handDetected = false;

      // --- Audio Globals ---
      let audioCtx, analyser, gainNode, audioElement, audioSource;
      let audioDataArray;
      let audioPlaying = false;
      let bass = 0,
        mid = 0,
        treble = 0;
      let isBeat = false;
      let beatPulse = 0;
      let beatEnergy = 0;
      let lastBeatTime = 0;
      const beatMinInterval = 200;
      const beatDecay = 0.98;
      const smoothing = 0.82;
      const energyHistory = [];

      init();

      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.02);

        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000,
        );
        camera.position.set(0, 2, 8);

        renderer = new THREE.WebGLRenderer({
          antialias: true,
          powerPreference: "high-performance",
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        const ambient = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambient);

        loadModel();

        window.addEventListener("resize", onResize);
        initMediaPipe();
        animate();
      }

      function loadModel() {
        const loader = new GLTFLoader();
        console.log("Loading:", CONFIG.modelPath);

        loader.load(
          CONFIG.modelPath,
          (gltf) => {
            console.log("Model loaded", gltf);

            const box = new THREE.Box3().setFromObject(gltf.scene);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            gltf.scene.position.x += gltf.scene.position.x - center.x;
            gltf.scene.position.y += gltf.scene.position.y - center.y;
            gltf.scene.position.z += gltf.scene.position.z - center.z;

            const maxDim = Math.max(size.x, size.y, size.z);
            const targetSize = 4.0;
            const scale = targetSize / maxDim;
            gltf.scene.scale.set(scale, scale, scale);

            createParticles(gltf.scene);

            const loading = document.getElementById("loading");
            loading.style.opacity = 0;
            setTimeout(() => (loading.style.display = "none"), 1000);
          },
          undefined,
          (err) => {
            console.error(err);
            document.getElementById("loading").innerText =
              "Error Loading Model";
          },
        );
      }

      function createParticles(model) {
        const vertices = [];
        model.traverse((child) => {
          if (child.isMesh) {
            const pos = child.geometry.attributes.position;
            const matrix = child.matrixWorld;
            for (let i = 0; i < pos.count; i++) {
              const v = new THREE.Vector3()
                .fromBufferAttribute(pos, i)
                .applyMatrix4(matrix);
              vertices.push(v);
            }
          }
        });

        if (vertices.length === 0) return;

        // 2. Center the Vertices Dynamically (Fixed)
        const box = new THREE.Box3().setFromPoints(vertices);
        const center = box.getCenter(new THREE.Vector3());

        console.log("Centering Particle Cloud:", center);

        const count = CONFIG.particleCount;
        const positions = new Float32Array(count * 3);
        const targets = new Float32Array(count * 3);
        const randoms = new Float32Array(count * 3);
        const sizes = new Float32Array(count);
        const extras = new Float32Array(count); // New Attribute

        const baseCount = 80000;

        for (let i = 0; i < count; i++) {
          const i3 = i * 3;
          const v = vertices[Math.floor(Math.random() * vertices.length)];

          // Center the target position
          targets[i3 + 0] = v.x - center.x;
          targets[i3 + 1] = v.y - center.y;
          targets[i3 + 2] = v.z - center.z;

          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const r = 10.0 + Math.random() * 10.0;

          positions[i3 + 0] = r * Math.sin(phi) * Math.cos(theta);
          positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
          positions[i3 + 2] = r * Math.cos(phi);

          randoms[i3 + 0] = Math.random();
          randoms[i3 + 1] = Math.random();
          randoms[i3 + 2] = Math.random();
          sizes[i] = Math.random();

          // Mark Extra Particles logic
          if (i >= baseCount) {
            extras[i] = 1.0;
          } else {
            extras[i] = 0.0;
          }
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(targets, 3),
        );
        geometry.setAttribute("aTarget", new THREE.BufferAttribute(targets, 3));
        geometry.setAttribute(
          "aScatter",
          new THREE.BufferAttribute(positions, 3),
        );
        geometry.setAttribute("aRandom", new THREE.BufferAttribute(randoms, 3));
        geometry.setAttribute("aSize", new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute("aExtra", new THREE.BufferAttribute(extras, 1));

        const material = new THREE.ShaderMaterial({
          uniforms: {
            uTime: { value: 0 },
            uProgress: { value: 0 },
            uBeatPulse: { value: 0 },
            uAudioAmp: { value: 0 },
            // Tuned Colors from Comparison
            uColorStem: { value: new THREE.Color("#887700") },
            uColorPetal: { value: new THREE.Color("#aa44ff") },
            uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) },
          },
          vertexShader: `
            uniform float uTime;
            uniform float uProgress;
            uniform float uBeatPulse;
            uniform float uAudioAmp;
            
            attribute vec3 aScatter;
            attribute vec3 aRandom;
            attribute float aSize;
            attribute float aExtra;
            
            varying float vAlpha;
            varying float vBeatPulse;
            varying float vY;

            void main() {
                vBeatPulse = uBeatPulse;
                
                float reactionMask = smoothstep(0.4, 0.6, aRandom.y);
                
                vec3 pos = mix(position, aScatter, uProgress * reactionMask);
                pos *= (1.0 + uBeatPulse * 0.12);
                
                float sway = sin(pos.y * 0.5 + uTime * 0.6) * 0.15;
                pos.x += sway * (1.0 - uProgress);
                
                float time = uTime * 0.5;
                vec3 noise = vec3(
                    sin(time + aRandom.x * 10.0),
                    cos(time * 0.9 + aRandom.y * 10.0),
                    sin(time * 1.1 + aRandom.z * 10.0)
                );
                
                float amp = (0.02 + (uProgress * 0.5 + uAudioAmp * 0.15) * reactionMask);
                pos += noise * amp;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                
                // Reduced Size for Clarity
                float baseSize = 3.5 * aSize; 
                float beatSize = 1.0 + uBeatPulse * 0.8;
                float finalSize = baseSize * (1.0 + uProgress * 2.0) * beatSize;
                
                gl_PointSize = finalSize * (40.0 / -mvPosition.z);
                
                // --- Alpha Visibility Logic ---
                if (aExtra > 0.5) {
                    // Extras: Fade in during dissipation
                    vAlpha = smoothstep(0.0, 0.5, uProgress) * 0.8;
                } else {
                    // Base: Lower alpha to prevent blowout
                    vAlpha = (0.6 - uProgress * 0.3);
                }
                
                if (mvPosition.z > 0.0) vAlpha = 0.0;
                
                vY = pos.y;
            }
          `,
          fragmentShader: `
            uniform vec3 uColorStem;
            uniform vec3 uColorPetal;
            varying float vAlpha;
            varying float vBeatPulse;
            varying float vY;
            
            void main() {
                vec2 uv = gl_PointCoord - 0.5;
                float r = length(uv);
                if(r > 0.5) discard;
                
                float glow = pow(1.0 - (r * 2.0), 2.0);
                
                float mixFactor = smoothstep(-1.2, 1.8, vY);
                vec3 baseColor = mix(uColorStem, uColorPetal, mixFactor);
                
                vec3 col = mix(baseColor, vec3(0.9, 0.9, 1.0), vBeatPulse * 0.15);
                
                gl_FragColor = vec4(col, glow * vAlpha);
            }
          `,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);
      }

      function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        const time = performance.now() * 0.001;
        let audioAmp = 0;

        if (audioPlaying && analyser) {
          analyser.getByteFrequencyData(audioDataArray);
          const bufLen = analyser.frequencyBinCount;
          const bassEnd = 7;
          const midEnd = 41;
          const trebleEnd = Math.min(128, bufLen);

          const rawBass = bandAvg(0, bassEnd);
          const rawMid = bandAvg(bassEnd, midEnd);
          const rawTreble = bandAvg(midEnd, trebleEnd);

          bass = bass * smoothing + rawBass * (1 - smoothing);
          mid = mid * smoothing + rawMid * (1 - smoothing);
          treble = treble * smoothing + rawTreble * (1 - smoothing);

          detectBeat(rawBass);
          beatPulse *= 0.92;
          if (isBeat) beatPulse = 1.0;

          if (!handDetected) {
            // Audio Pulse Fix
            targetProgress = beatPulse * 0.02;
            audioAmp = bass * 0.4 + mid * 1.5 + treble * 2.0;
          } else {
            audioAmp = 0;
          }

          const info = document.getElementById("audio-info");
          info.textContent = `Bass: ${(bass * 100).toFixed(0)} | Mid: ${(mid * 100).toFixed(0)} | Treble: ${(treble * 100).toFixed(0)}${isBeat ? " ðŸ’¥" : ""}`;
        }

        uProgress += (targetProgress - uProgress) * 0.3;

        if (particles) {
          particles.material.uniforms.uTime.value = time;
          particles.material.uniforms.uProgress.value = uProgress;
          particles.material.uniforms.uBeatPulse.value = beatPulse;
          particles.material.uniforms.uAudioAmp.value = audioAmp;
          particles.rotation.y = time * 0.15;
        }

        controls.update();
        renderer.render(scene, camera);
      }

      function bandAvg(start, end) {
        let sum = 0;
        for (let i = start; i < end; i++) sum += audioDataArray[i];
        return sum / (end - start) / 255;
      }

      function detectBeat(energy) {
        energyHistory.push(energy);
        if (energyHistory.length > 60) energyHistory.shift();
        const avg =
          energyHistory.reduce((a, b) => a + b, 0) / energyHistory.length;
        const adaptive = Math.max(0.15, avg * 1.15);
        const now = performance.now();

        if (
          energy > adaptive &&
          energy > beatEnergy &&
          now - lastBeatTime > beatMinInterval
        ) {
          isBeat = true;
          lastBeatTime = now;
        } else {
          isBeat = false;
        }
        beatEnergy = energy * beatDecay;
      }

      window.toggleAudio = async function () {
        const btn = document.getElementById("play-btn");
        const status = document.getElementById("audio-status");

        if (audioPlaying) {
          audioElement.pause();
          audioPlaying = false;
          btn.textContent = "â–¶ Play Music";
          status.textContent = "ðŸŽµ Paused";
          return;
        }

        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          analyser = audioCtx.createAnalyser();
          analyser.fftSize = 512;
          analyser.smoothingTimeConstant = 0.75;
          audioDataArray = new Uint8Array(analyser.frequencyBinCount);
          gainNode = audioCtx.createGain();
          gainNode.gain.value = 1.0;
          audioElement = new Audio(CONFIG.audioPath);
          audioElement.crossOrigin = "anonymous";
          audioElement.loop = true;
          await new Promise((resolve, reject) => {
            audioElement.addEventListener("canplaythrough", resolve, {
              once: true,
            });
            audioElement.addEventListener("error", (e) => reject(e), {
              once: true,
            });
            audioElement.load();
          });
          audioSource = audioCtx.createMediaElementSource(audioElement);
          audioSource.connect(analyser);
          analyser.connect(gainNode);
          gainNode.connect(audioCtx.destination);
        }

        if (audioCtx.state === "suspended") await audioCtx.resume();
        audioElement.play();
        audioPlaying = true;
        btn.textContent = "â¸ Pause Music";
        status.textContent = "ðŸŽµ Playing â€” Trouble Cleansing";
      };

      function initMediaPipe() {
        const videoElement = document.getElementById("webcam");
        const hands = new Hands({
          locateFile: (file) =>
            `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
        });
        hands.setOptions({
          maxNumHands: 1,
          modelComplexity: 1,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5,
        });
        hands.onResults(onHandsResults);
        const cam = new Camera(videoElement, {
          onFrame: async () => {
            await hands.send({ image: videoElement });
          },
          width: 320,
          height: 240,
        });
        cam.start();
      }

      function onHandsResults(results) {
        const statusElement = document.getElementById("gesture-state");
        if (
          results.multiHandLandmarks &&
          results.multiHandLandmarks.length > 0
        ) {
          const landmarks = results.multiHandLandmarks[0];
          const gesture = detectGesture(landmarks);
          handDetected = true;
          if (gesture === "PALM") {
            statusElement.innerText = "ðŸ–ï¸ OPEN PALM (Dissipating)";
            statusElement.style.color = "#00d4ff";
            targetProgress = 1;
          } else if (gesture === "FIST") {
            statusElement.innerText = "âœŠ FIST (Converging)";
            statusElement.style.color = "#ff0080";
            targetProgress = 0;
          } else {
            statusElement.innerText = "Thinking...";
            statusElement.style.color = "white";
            handDetected = false;
          }
        } else {
          statusElement.innerText = audioPlaying
            ? "ðŸŽµ Audio-Reactive Mode"
            : "No Hand Detected";
          statusElement.style.color = audioPlaying ? "#7928ca" : "#888";
          handDetected = false;
        }
      }

      function detectGesture(landmarks) {
        const wrist = landmarks[0];
        const tips = [
          landmarks[8],
          landmarks[12],
          landmarks[16],
          landmarks[20],
        ];
        let avgDist = 0;
        tips.forEach((tip) => {
          const d = Math.sqrt(
            Math.pow(tip.x - wrist.x, 2) +
              Math.pow(tip.y - wrist.y, 2) +
              Math.pow(tip.z - wrist.z, 2),
          );
          avgDist += d;
        });
        avgDist /= tips.length;
        if (avgDist < 0.2) return "FIST";
        if (avgDist > 0.35) return "PALM";
        return "UNKNOWN";
      }
    </script>
  </body>
</html>
